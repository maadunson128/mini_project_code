// Replace with your Firebase Realtime Database URL and API key
const FIREBASE_URL = 'https://water-monitoring-d4064-default-rtdb.asia-southeast1.firebasedatabase.app/';
const API_KEY = 'AIzaSyDCwzjvqjrB5DIN8NQvSq_bsZM_FLs_U1c';

function updateGoogleSheetWithNewData() {
  // Fetch the 'lastID' from Firebase (most recent entry's ID)
  const lastIdResponse = UrlFetchApp.fetch(`${FIREBASE_URL}lastID.json?auth=${API_KEY}`);
  const lastIdInFirebase = JSON.parse(lastIdResponse.getContentText());

  // If lastIdInFirebase is null or undefined, exit
  if (lastIdInFirebase === null || lastIdInFirebase === undefined) {
    Logger.log('No data in Firebase.');
    return; // No data, exit the function early
  }

  // Fetch the 'waterData' from Firebase
  const waterDataResponse = UrlFetchApp.fetch(`${FIREBASE_URL}waterData.json?auth=${API_KEY}`);
  const waterData = JSON.parse(waterDataResponse.getContentText());

  // Open the active Google Sheet and specify the sheet names
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet1 = ss.getSheetByName('Sheet1'); // Data storage
  const sheet2 = ss.getSheetByName('Sheet2'); // Daily consumption
  const sheet3 = ss.getSheetByName('Sheet3'); // Monthly consumption

  // Get the last row in Sheet1
  const lastRow = sheet1.getLastRow();
  const lastUniqueIdInSheet = lastRow > 1 ? sheet1.getRange(lastRow, 1).getValue() : 0; // ID in the last row

  // Get the previous water volume and timestamp from the last entry in Sheet1
  let previousWaterVolume = null;
  let previousTimestamp = null;

  if (lastRow > 1) {
    previousWaterVolume = sheet1.getRange(lastRow, 4).getValue(); // Assuming waterVolume is in column 4
    previousTimestamp = new Date(sheet1.getRange(lastRow, 2).getValue()); // Assuming timestamp is in column 2
  }

  // Check if the last ID in Sheet1 is the same as the last ID in Firebase
  if (parseInt(lastUniqueIdInSheet) === parseInt(lastIdInFirebase)) {
    Logger.log('No new data to process as the last ID in Sheet1 matches the last ID in Firebase.');
    return; // No new data, exit the function early
  }

  // Process new data only if there is new data in Firebase
  let newDataToAppend = [];

  // Initialize objects to hold cumulative consumptions
  let dailyConsumptions = {};   // {'yyyy-MM-dd': cumulativeConsumption}
  let monthlyConsumptions = {}; // {'yyyy-MM': cumulativeConsumption}

  // Process the data from Firebase and update Sheet1
  let newUniqueIds = Object.keys(waterData)
    .map(id => parseInt(id))
    .filter(id => id > lastUniqueIdInSheet)
    .sort((a, b) => a - b);

  for (const uniqueId of newUniqueIds) {
    const entry = waterData[uniqueId];
    const timestamp = new Date(entry.timestamp);
    const waterLevel = entry.waterLevel;
    const waterVolume = entry.waterVolume;

    // Add new data to the array for appending to Sheet1
    newDataToAppend.push([uniqueId, entry.timestamp, waterLevel, waterVolume]);

    // Calculate consumption since last data point
    if (previousWaterVolume !== null) {
      let consumption = previousWaterVolume - waterVolume; // Difference in waterVolume
      if (consumption > 0) { // Only when waterVolume decreases
        // Get date and month
        const date = Utilities.formatDate(timestamp, Session.getScriptTimeZone(), "yyyy-MM-dd");
        const month = Utilities.formatDate(timestamp, Session.getScriptTimeZone(), "yyyy-MM");

        // Update cumulative daily consumption
        dailyConsumptions[date] = (dailyConsumptions[date] || 0) + consumption;

        // Update cumulative monthly consumption
        monthlyConsumptions[month] = (monthlyConsumptions[month] || 0) + consumption;
      }
    }
    // Update previous water volume and timestamp
    previousWaterVolume = waterVolume;
    previousTimestamp = timestamp;
  }

  // Append new data to Sheet1
  if (newDataToAppend.length > 0) {
    sheet1.getRange(sheet1.getLastRow() + 1, 1, newDataToAppend.length, 4).setValues(newDataToAppend);
    Logger.log(`${newDataToAppend.length} new rows added to Sheet1 in sorted order.`);
  } else {
    Logger.log('No new data to append to Sheet1.');
  }

  // Update Sheet2 (Daily Consumption)
  updateConsumptionSheet(sheet2, dailyConsumptions);

  // Update Sheet3 (Monthly Consumption)
  updateConsumptionSheet(sheet3, monthlyConsumptions);
}

function updateConsumptionSheet(sheet, consumptions) {
  // consumptions is an object {'key': cumulativeConsumption}, where key is date (yyyy-MM-dd) or month (yyyy-MM)
  const data = sheet.getDataRange().getValues();
  const existingKeys = {}; // Map from key to row index (1-based)
  for (let rowIndex = 2; rowIndex <= data.length; rowIndex++) { // Start from row 2 to skip header
    let keyCell = data[rowIndex - 1][0]; // data[1][0], data[2][0], etc.

    // Ensure keyCell is a string formatted the same way as in consumptions
    let key;
    if (keyCell instanceof Date) {
      // It's a Date object. Format it as a string.
      const format = keyCell.getDate() === 1 ? "yyyy-MM" : "yyyy-MM-dd";
      key = Utilities.formatDate(keyCell, Session.getScriptTimeZone(), format);
    } else {
      key = keyCell.toString().trim(); // Ensure no leading/trailing spaces
    }

    existingKeys[key] = rowIndex; // Map key to row index
  }

  for (const key in consumptions) {
    if (consumptions.hasOwnProperty(key)) {
      const consumption = consumptions[key];
      if (existingKeys.hasOwnProperty(key)) {
        // Key exists in sheet, update the consumption
        const rowIndex = existingKeys[key];
        const existingValue = sheet.getRange(rowIndex, 2).getValue();
        sheet.getRange(rowIndex, 2).setValue(existingValue + consumption);
      } else {
        // Key does not exist, append new row
        sheet.appendRow([key, consumption]);
      }
    }
  }
}

